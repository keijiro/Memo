# MiniBokeh パッケージ開発における AI コーディングエージェント活用の記録

MiniBokeh パッケージの開発では、立ち上げからリリースまで AI コーディングエージェントを活用した。実用的なプロジェクトにおいてここまで本格的に活用したのは、個人的には初めての事例となる。

使い方としてはだいぶ保守的な手法を採っていて、開発サイクルを全自動で回すようなことは狙わず、逐一作業指示を行なって開発を進めていった。

## 使用ツール

### Claude Code

主にコーディングに用いた。通常の Max プランのため、Opus モデルへのフォールバックが度々発生した。

### Gemini CLI

開発を進める際に URP や SRP Core パッケージの解析が必要になった際に利用した。単純に反応が早くて使いやすいのと、Claude のトークン節約のため。Flash へのフォールバックを避けるために API Key を使用。

### OpenAI Codex

主にドキュメント (README.md) のプルーフリードに利用した。これもトークン節約のため。ChatGPT Plus を契約しているので、実は Codex がコスト面で最も優れているが、反応が遅いため反復作業には向いていない。

## Hex ボケ実装まで

まず、最初の骨組みとなる部分は手作業で作成した。

- Render Graph を使用した Renderer Feature の基本的な実装。
- カメラ側に Controller コンポーネントを付与し、それによってパラメーター制御を行う仕組み。
- Renderer Feature 内に Blit 相当の処理を組み、それによってフルスクリーンエフェクトを適用する。
  - ただし、標準の Blit は単一テクスチャ入力しか対応していないので、Blit はカスタム実装を用いる。
- カスタム Blit 実装に対応したカスタムシェーダー。

ここまでの作業を Claude Code に行わせることも不可能ではないが、未だ Render Graph に関する知見が十分に蓄積されていないため、あまり良いものをスッとは出してくれない。これはまさに「自分で手を動かした方が早い」部分だと思う。

ここから先の実装については Claude Code に委譲。論文 PDF をワーキングディレクトリに置いて、それを参照して骨組みの中に実装するよう指示した。僅か数分で実装は完了。大きな勘違いが存在したものの、それを除けば実装にほぼ問題は無かった。

勘違いされた点：Claude Code はボケ（ブラー）処理を tent filter を使って実装してきた。レンズボケは重み付け無しに一様にサンプリングするのが正解であり、大きな特徴でもある。その基本が分かっていなかったのは、少し意外だった。

自前で用意した骨組みの方に問題があり、その後の検証で若干手間取ったものの、ここまでは難なくクリアといった感じだった。

## 最適化とリファクタリング

エフェクトが想定通り動くようになったところで Xcode のプロファイラを使って最適化を開始。動的分岐、ループ・アンロール、それらのハイブリッドなど、いくつかの選択肢を実際に実装して試してみる。こういった「ちょっと組んでみて」という作業を気軽に実施できるのは、コーディングエージェントを使った開発の良いところだと思う。ただし、計測作業は手作業で行わなければいけないので、作業時間が大幅に短縮されたという印象は無い。通常の C# コードのプロファイリングならともかくとして、モバイルデバイス上で動くシェーダーコードのプロファイリングなどは、どうすれば上手くエージェント任せにできるか現状では見当もつかないので、手作業でやらざるを得ない。

結局のところ、単純に `unroll` で `for` ループをアンロールしつつ、適宜 `conitnue` でスキップさせるアプローチが、速度と可読性の面で最も良かったので、それを採用することにした。

リファクタリングについては、手作業を交えつつ具体的な指示によって進めていく事が多かった。「このファイルをリファクタリングして」と丸投げすることも可能だが、今までの経験から言って、結果は博打になることが多かった。特に Render Graph 関連の処理は知見が少ないためか、筋の悪いコードを出力することが多いように感じる。今回のパッケージは最終的に自分でメンテナンスできる状態を実現したかったので、自分の読みやすいコードへと書き換えてもらう作業を行なっていくことになった。

## 円形ボケの実装

次に kecho 氏に提案された、複素数カーネルを使用した円形ボケの実装を行うことにした。これは非常に賢い手法で、円形のボケを単純な separable filter として実装できる。ただし複素数が絡んでくるため、帯域幅は倍増する（テクスチャ数を増やさざるを得ないので倍増以上か）。

実装にあたっては、参考となる Shadertoy の glsl をサブディレクトリに配置し、ついでに論文の PDF も置いたうえで、それを追加機能として実装することを Claude Code に依頼した。複素数カーネル配列の解釈に混乱があり、最初はうまく動かなかった。カーネルの `float4` 配列のうち `.xy` 成分だけを利用する、という、少し直感的ではない仕様だったのが問題だったようだ。丸投げで完遂できたら楽だなと思っていたが、この勘違いを直すためにちゃんと処理内容を把握する必要が生じ、やはり手抜きはできないものだなと痛感した。最終的に勘違いに気づき、修正を指示して解決。もっと Claude Code を酷使すれば自力解決もできたのかもしれないが、どうせリファクタリングを行う際にコードの理解は必要になるので、この程度の回り道はしょうがないのかもしれない。

<!--
- パラメーターの設計については UX が絡むので、実際に手で感覚を確かめながら、相談して修正する必要がありました。
- 次に複素数カーネルを使った円形ボケを追加。これは Shadertoy のコードと論文を参考資料にして Claude Code で生成。元のコードの解釈の仕方で混乱があったものの、いろいろ試すうちに動くようになりました。
- 円形ボケの処理は MRT でパス数を大幅に減らせるものの、Render Graph + MRT の知見もほぼ存在しないので、この作業は手動で対応。SRP コードの解析を行う際には Gemini CLI を主に使用（レスポンスが速いのと Claude の使用量節約のため）
- エディタコード (Inspector) は Claude Code にほぼ全投げで完成。
- C# / HLSL コードのリファクタリングは Claude Code と手作業が半々ぐらいでした。Claude Code は、作業内容を指示して実行させる（例えば、このクラスのこの機能を別のクラスに移し替えて、とか）には便利ですが、「リファクタリングして」で丸投げすると、かなり筋の悪いことを行うことが多いです。そのため、基本的には手作業でリファクタリングしつつ、まとまった量の面倒な作業が発生した際には Claude に依頼する、と言うような連携を行いました。あと、RenderGraph が絡むコードを扱うのは、やはりだいぶ不得手。そこはほぼ手作業になりました。
- ドキュメントの執筆には Codex (OpenAI/GPT-5) を活用しました。単純に Claude の使用量を節約したかったのと、文章の生成では GPT-5 の方が優れているように感じたためです。ただし、全任せにすると過剰に文章を生成してしまうので、下書きは自分で書くようにしました。
-->
